import * as ad from "../types/ad";
export declare const objDictSimple: {
    /**
     * Encourage the input value to be close to negative infinity
     */
    minimal: (x: ad.Num) => ad.Num;
    /**
     * Encourage the input value to be close to infinity
     */
    maximal: (x: ad.Num) => ad.Num;
    /**
     * Encourage the inputs to have the same value: `(x - y)^2`
     */
    equal: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Encourage x to be greater than or equal to y: `max(0,y - x)^2`
     */
    greaterThan: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Encourage x to be less than or equal to y: `max(0,x - y)^2`
     */
    lessThan: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Repel point `a` from another scalar `b` with weight `weight`.
     */
    repelPt: (weight: ad.Num, a: ad.Num[], b: ad.Num[]) => ad.Num;
    /**
     * Repel scalar `c` from another scalar `d`.
     */
    repelScalar: (c: ad.Num, d: ad.Num) => ad.Num;
};
export declare const objDictGeneral: {
    /**
     * Encourage the center of `sTop` to be above the center of `sBottom`.
     * Only works for shapes with property `center`.
     */
    below: ([tBottom, sBottom]: [string, any], [tTop, sTop]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sBottom` to be below the center of `sTop`.
     */
    above: ([tTop, sTop]: [string, any], [tBottom, sBottom]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sLeft` to be leftwards to the center of `sRight`.
     */
    leftwards: ([tLeft, sLeft]: [string, any], [tRight, sRight]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sRight` to be rightwards to the center of `sLeft`.
     */
    rightwards: ([tRight, sRight]: [string, any], [tLeft, sLeft]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage shape `s1` to have the same center position as shape `s2`.
     */
    sameCenter: ([t1, s1]: [string, any], [t2, s2]: [string, any]) => ad.Num;
    /**
     * Try to repel shapes `s1` and `s2` with some weight.
     */
    notTooClose: ([t1, s1]: [string, any], [t2, s2]: [string, any], weight?: number) => ad.Num;
    /**
     * Try to place shape `s1` near shape `s2` (putting their centers at the same place).
     */
    near: ([t1, s1]: [string, any], [t2, s2]: [string, any], offset?: number) => ad.Num;
    /**
     * Try to place shape `s1` near a location `(x, y)`.
     */
    nearPt: ([t1, s1]: [string, any], x: any, y: any) => ad.Num;
    /**
     * Repel the angle between the p1-p0 and p1-p2 away from 0 and 180 degrees.
     * NOTE: angles more than `range` degrees from 0 or 180 deg are considered satisfied.
     */
    nonDegenerateAngle: ([t0, p0]: [string, any], [t1, p1]: [string, any], [t2, p2]: [string, any], strength?: number, range?: number) => ad.Num;
};
export declare const objDictSpecific: {
    centerLabelAbove: ([t1, s1]: [string, any], [t2, s2]: [string, any], w: number) => ad.Num;
    /**
     * Try to center a label `s2` with respect to some shape `s1`.
     */
    centerLabel: ([t1, s1]: [string, any], [t2, s2]: [string, any], w: number, padding?: number) => ad.Num;
    /**
     * try to make distance between a point and a segment `s1` = padding.
     */
    pointLineDist: (point: ad.Num[], [t1, s1]: [string, any], padding: ad.Num) => ad.Num;
};
export declare const objDict: {
    centerLabelAbove: ([t1, s1]: [string, any], [t2, s2]: [string, any], w: number) => ad.Num;
    /**
     * Try to center a label `s2` with respect to some shape `s1`.
     */
    centerLabel: ([t1, s1]: [string, any], [t2, s2]: [string, any], w: number, padding?: number) => ad.Num;
    /**
     * try to make distance between a point and a segment `s1` = padding.
     */
    pointLineDist: (point: ad.Num[], [t1, s1]: [string, any], padding: ad.Num) => ad.Num;
    /**
     * Encourage the center of `sTop` to be above the center of `sBottom`.
     * Only works for shapes with property `center`.
     */
    below: ([tBottom, sBottom]: [string, any], [tTop, sTop]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sBottom` to be below the center of `sTop`.
     */
    above: ([tTop, sTop]: [string, any], [tBottom, sBottom]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sLeft` to be leftwards to the center of `sRight`.
     */
    leftwards: ([tLeft, sLeft]: [string, any], [tRight, sRight]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage the center of `sRight` to be rightwards to the center of `sLeft`.
     */
    rightwards: ([tRight, sRight]: [string, any], [tLeft, sLeft]: [string, any], offset?: number) => ad.Num;
    /**
     * Encourage shape `s1` to have the same center position as shape `s2`.
     */
    sameCenter: ([t1, s1]: [string, any], [t2, s2]: [string, any]) => ad.Num;
    /**
     * Try to repel shapes `s1` and `s2` with some weight.
     */
    notTooClose: ([t1, s1]: [string, any], [t2, s2]: [string, any], weight?: number) => ad.Num;
    /**
     * Try to place shape `s1` near shape `s2` (putting their centers at the same place).
     */
    near: ([t1, s1]: [string, any], [t2, s2]: [string, any], offset?: number) => ad.Num;
    /**
     * Try to place shape `s1` near a location `(x, y)`.
     */
    nearPt: ([t1, s1]: [string, any], x: any, y: any) => ad.Num;
    /**
     * Repel the angle between the p1-p0 and p1-p2 away from 0 and 180 degrees.
     * NOTE: angles more than `range` degrees from 0 or 180 deg are considered satisfied.
     */
    nonDegenerateAngle: ([t0, p0]: [string, any], [t1, p1]: [string, any], [t2, p2]: [string, any], strength?: number, range?: number) => ad.Num;
    /**
     * Encourage the input value to be close to negative infinity
     */
    minimal: (x: ad.Num) => ad.Num;
    /**
     * Encourage the input value to be close to infinity
     */
    maximal: (x: ad.Num) => ad.Num;
    /**
     * Encourage the inputs to have the same value: `(x - y)^2`
     */
    equal: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Encourage x to be greater than or equal to y: `max(0,y - x)^2`
     */
    greaterThan: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Encourage x to be less than or equal to y: `max(0,x - y)^2`
     */
    lessThan: (x: ad.Num, y: ad.Num) => ad.Num;
    /**
     * Repel point `a` from another scalar `b` with weight `weight`.
     */
    repelPt: (weight: ad.Num, a: ad.Num[], b: ad.Num[]) => ad.Num;
    /**
     * Repel scalar `c` from another scalar `d`.
     */
    repelScalar: (c: ad.Num, d: ad.Num) => ad.Num;
};
//# sourceMappingURL=Objectives.d.ts.map