import { Ellipse } from "../shapes/Ellipse";
import { Context } from "../shapes/Samplers";
import * as ad from "../types/ad";
import { ArgVal, Color, ColorV, FloatV, PathDataV, PtListV, StrV, TupV, VectorV } from "../types/value";
/**
 * Static dictionary of computation functions
 * TODO: consider using `Dictionary` type so all runtime lookups are type-safe, like here https://codeburst.io/five-tips-i-wish-i-knew-when-i-started-with-typescript-c9e8609029db
 * TODO: think about user extension of computation dict and evaluation of functions in there
 */
export declare const compDict: {
    makePath: (_context: Context, start: [ad.Num, ad.Num], end: [ad.Num, ad.Num], curveHeight: ad.Num, padding: ad.Num) => PathDataV<ad.Num>;
    /**
     * Return `i`th element of list `xs, assuming lists only hold floats.
     */
    get: (_context: Context, xs: ad.Num[], i: number) => FloatV<ad.Num>;
    /**
     * Return a paint color of elements `r`, `g`, `b`, `a` (red, green, blue, opacity).
     */
    rgba: (_context: Context, r: ad.Num, g: ad.Num, b: ad.Num, a: ad.Num) => ColorV<ad.Num>;
    selectColor: (_context: Context, color1: Color<ad.Num>, color2: Color<ad.Num>, level: ad.Num) => ColorV<ad.Num>;
    /**
     * Return a paint color of elements `h`, `s`, `v`, `a` (hue, saturation, value, opacity).
     */
    hsva: (_context: Context, h: ad.Num, s: ad.Num, v: ad.Num, a: ad.Num) => ColorV<ad.Num>;
    /**
     * Return a paint of none (no paint)
     */
    none: (_context: Context) => ColorV<ad.Num>;
    /**
     * Return `acosh(x)`.
     */
    acosh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `acos(x)`.
     */
    acos: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `asin(x)`.
     */
    asin: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `asinh(x)`.
     */
    asinh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `atan(x)`.
     */
    atan: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `atan2(y,x)`.
     */
    atan2: (_context: Context, x: ad.Num, y: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `atanh(x)`.
     */
    atanh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `cbrt(x)`.
     */
    cbrt: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `ceil(x)`.
     */
    ceil: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `cos(x)`.
     */
    cos: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `cosh(x)`.
     */
    cosh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `exp(x)`.
     */
    exp: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `expm1(x)`.
     */
    expm1: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `floor(x)`.
     */
    floor: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `log(x)`.
     */
    log: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `log2(x)`.
     */
    log2: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `log10(x)`.
     */
    log10: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `log1p(x)`.
     */
    log1p: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `pow(x,y)`.
     */
    pow: (_context: Context, x: ad.Num, y: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `round(x)`.
     */
    round: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `sign(x)`.
     */
    sign: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `sin(x)`.
     */
    sin: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `sinh(x)`.
     */
    sinh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `tan(x)`.
     */
    tan: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `tanh(x)`.
     */
    tanh: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return `trunc(x)`.
     */
    trunc: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the dot product of `v` and `w`.
     */
    dot: (_context: Context, v: ad.Num[], w: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the length of the line or arrow shape `[type, props]`.
     */
    length: (_context: Context, [t, props]: [string, any]) => FloatV<ad.Num>;
    /**
     * Concatenate a list of strings
     */
    concat: (_context: Context, ...strings: string[]) => StrV;
    /**
     * Return the normalized version of vector `v`.
     */
    normalize: (_context: Context, v: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    pathFromPoints: (_context: Context, pathType: string, pts: ad.Pt2[]) => PathDataV<ad.Num>;
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    quadraticCurveFromPoints: (_context: Context, pathType: string, pts: ad.Pt2[]) => PathDataV<ad.Num>;
    /**
     * Draw a curve interpolating three given points.
     * (Note that this is different from specifying the
     * three control points of a quadratic Bézier curve,
     * since a Bézier does not interpolate the middle
     * control point.)
     */
    interpolateQuadraticFromPoints: (_context: Context, pathType: string, p0: ad.Pt2, p1: ad.Pt2, p2: ad.Pt2) => PathDataV<ad.Num>;
    /**
     * Given a list of points `pts`, returns a `PathData` that can be used as input to the `Path` shape's `pathData` attribute to be drawn on the screen.
     */
    cubicCurveFromPoints: (_context: Context, pathType: string, pts: ad.Pt2[]) => PathDataV<ad.Num>;
    /**
     * Return two points parallel to line `s1` using its normal line `s2`.
     */
    unitMark: (_context: Context, [, s1]: [string, any], [, s2]: [string, any], t: string, padding: ad.Num, barSize: ad.Num) => PtListV<ad.Num>;
    /**
     * Return two points to "cap off" the line made in `unitMark`.
     */
    unitMark2: (_context: Context, [start, end]: [ad.Pt2, ad.Pt2], t: string, padding: ad.Num, size: ad.Num) => PtListV<ad.Num>;
    /**
     * Return series of elements that can render an arc SVG. See: https://css-tricks.com/svg-path-syntax-illustrated-guide/ for the "A" spec.
     * @param pathType: either "open" or "closed." whether the SVG should automatically draw a line between the final point and the start point
     * @param start: coordinate to start drawing the arc
     * @param end: coordinate to finish drawing the arc
     * @param radius: width and height of the ellipse to draw the arc along (i.e. [width, height])
     * @param rotation: angle in degrees to rotate ellipse about its center
     * @param largeArc: 0 to draw shorter of 2 arcs, 1 to draw longer
     * @param arcSweep: 0 to rotate CCW, 1 to rotate CW
     * @returns: Elements that can be passed to Path shape spec to render an SVG arc
     */
    arc: (_context: Context, pathType: string, start: ad.Pt2, end: ad.Pt2, radius: ad.Pt2, rotation: ad.Num, largeArc: ad.Num, arcSweep: ad.Num) => PathDataV<ad.Num>;
    repeatedArcs: (_context: Context, innerStart: ad.Pt2, innerEnd: ad.Pt2, outerStart: ad.Pt2, outerEnd: ad.Pt2, innerRadius: ad.Pt2, repeat: ad.Num, spacing: ad.Num, arcSweep: ad.Num) => PathDataV<ad.Num>;
    /**
     * Return series of elements that render a "wedge", which is the same as the arc above except that it's connected to the circle center and filled
     * @param center: center of the circle on which the arc sits
     * @param start: coordinate to start drawing the arc
     * @param end: coordinate to finish drawing the arc
     * @param radius: width and height of the ellipse to draw the arc along (i.e. [width, height])
     * @param rotation: angle in degrees to rotate ellipse about its center
     * @param largeArc: 0 to draw shorter of 2 arcs, 1 to draw longer
     * @param arcSweep: 0 to rotate CCW, 1 to rotate CW
     * @returns: Elements that can be passed to Path shape spec to render an SVG arc
     */
    wedge: (_context: Context, center: ad.Pt2, start: ad.Pt2, end: ad.Pt2, radius: ad.Pt2, rotation: ad.Num, largeArc: ad.Num, arcSweep: ad.Num) => PathDataV<ad.Num>;
    /**
     * Find the point that is located at dist r along a line between p1 and p2.
     * @param p1: start point of line segment
     * @param p2: endpoint of line segment
     * @param r: distance from p1 to travel along the line
     * @returns: vector representation of the point of intersection
     */
    ptOnLine: (_context: Context, p1: ad.Num[], p2: ad.Num[], r: ad.Num) => VectorV<ad.Num>;
    /**
     * Return 0 if direction of rotation is CCW, 1 if direction of rotation is CW.
     * @param x1, y1: x, y coordinates of the circle/ellipse that the arc is drawn on
     * @param start: start point of the arc
     * @param end: end point of the arc
     * @returns: 0 or 1 depending on CCW or CW rotation
     */
    arcSweepFlag: (_context: Context, [x1, y1]: ad.Num[], start: ad.Pt2, end: ad.Pt2) => FloatV<ad.Num>;
    /**
     * Return the unsigned angle between vectors `u, v`, in radians.
     * Assumes that both u and v have nonzero magnitude.
     * The returned value will be in the range [0,pi].
     */
    angleBetween: (_context: Context, u: ad.Num[], v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the signed angle from vector `u` to vector `v`, in radians.
     * Assumes that both u and v are 2D vectors and have nonzero magnitude.
     * The returned value will be in the range [-pi,pi].
     */
    angleFrom: (_context: Context, u: ad.Num[], v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the 2D cross product of `u` and `v`, equal to the determinant of the 2x2 matrix [u v]
     */
    cross2D: (_context: Context, u: ad.Num[], v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the intersection of a line passing through
     * `a0` and `a1` with a line passing through `b0` and `b1`
     */
    lineLineIntersection: (_context: Context, a0: ad.Num[], a1: ad.Num[], b0: ad.Num[], b1: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return a point located at the midpoint between pts `start` and `end`
     */
    midpoint: (_context: Context, start: ad.Num[], end: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return a point located at the midpoint of a line `s1` but offset by `padding` in its normal direction (for labeling).
     */
    midpointOffset: (_context: Context, [t1, s1]: [string, any], padding: ad.Num) => TupV<ad.Num>;
    chevron: (_context: Context, [t1, s1]: [string, any], padding: ad.Num, ticks: ad.Num) => PtListV<ad.Num>;
    /**
     * Return a point located at `padding` of a line `s1` offset by `padding` in its normal direction (for making right angle markers).
     */
    innerPointOffset: (_context: Context, pt1: ad.Num[], pt2: ad.Num[], pt3: ad.Num[], padding: ad.Num) => VectorV<ad.Num>;
    /**
     * Create equally spaced tick marks centered at the midpoint of a line
     * @param pt1: starting point of a line
     * @param pt2: endping point of a line
     * @param spacing: space in px between each tick
     * @param numTicks: number of tick marks to create
     * @param tickLength: 1/2 length of each tick
     */
    ticksOnLine: (_context: Context, pt1: ad.Num[], pt2: ad.Num[], spacing: ad.Num, numTicks: ad.Num, tickLength: ad.Num) => PathDataV<ad.Num>;
    /**
     * Given two orthogonal segments that intersect at `intersection`, and a size `len`
     * return a path comprised of three points that describe a perpendicular mark at the angle where the segments intersect.
     */
    orientedSquare: (_context: Context, [t1, s1]: [string, any], [t2, s2]: [string, any], intersection: ad.Pt2, len: ad.Num) => PathDataV<ad.Num>;
    /**
             * Figure out which side of the rectangle `[t1, s1]` the `start->end` line is hitting, assuming that `start` is located at the rect's center and `end` is located outside the rectangle, and return the size of the OTHER side. Also assuming axis-aligned rectangle. This is used for arrow placement in box-and-arrow diagrams.
  
         @deprecated Don't use this function, it does not fully work
             */
    intersectingSideSize: (_context: Context, start: ad.Num[], end: ad.Num[], [t1, s1]: [string, any]) => FloatV<ad.Num>;
    /**
     * Given three lines `l1, l2, l3` that already form a triangle, return a path that describes the triangle (which can then be filled, etc.).
     */
    triangle: (_context: Context, [t1, l1]: any, [t2, l2]: any, [t3, l3]: any) => PathDataV<ad.Num>;
    /**
     * Return the average of floats `x` and `y`.
     */
    average2: (_context: Context, x: ad.Num, y: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the average of the floats in the list `xs`.
     */
    average: (_context: Context, xs: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the normalized version of vector `v`.
     */
    unit: (_context: Context, v: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Sample a random color once, with opacity `alpha` and colorType `colorType` (`"rgb"` or `"hsv"`).
     */
    sampleColor: ({ makeInput }: Context, alpha: ad.Num, colorType: string) => ColorV<ad.Num>;
    /**
     * Set the opacity of a color `color` to `frac`.
     */
    setOpacity: (_context: Context, color: Color<ad.Num>, frac: ad.Num) => ColorV<ad.Num>;
    /**
     * Multiply a matrix `m` and a vector `v` (where `v` is implicitly treated as a column vector).
     */
    mul: (_context: Context, m: ad.Num[][], v: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return the barycenter of the triangle with vertices `a`, `b`, `c`.
     */
    barycenter: (_context: Context, a: ad.Num[], b: ad.Num[], c: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return the circumcenter of the triangle with vertices `p`, `q`, `r`.
     */
    circumcenter: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return the circumradius of the triangle with vertices `p`, `q`, `r`.
     */
    circumradius: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the incenter of the triangle with vertices `p`, `q`, `r`.
     */
    incenter: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return the inradius of the triangle with vertices `p`, `q`, `r`.
     */
    inradius: (_context: Context, p: ad.Num[], q: ad.Num[], r: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the square of the number `x`.
     */
    sqr: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the square root of the number `x`. (NOTE: if `x < 0`, you may get `NaN`s)
     */
    sqrt: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the max of the numbers `x`, `y`.
     */
    max: (_context: Context, x: ad.Num, y: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the min of the numbers `x`, `y`.
     */
    min: (_context: Context, x: ad.Num, y: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the absolute value of the number `x`.
     */
    abs: (_context: Context, x: ad.Num) => FloatV<ad.Num>;
    /**
     * Convert the angle `theta` from degrees to radians.
     */
    toRadians: (_context: Context, theta: ad.Num) => FloatV<ad.Num>;
    /**
     * Convert the angle `theta` from radians to degrees.
     */
    toDegrees: (_context: Context, theta: ad.Num) => FloatV<ad.Num>;
    /**
     * Return the Euclidean norm of the vector `v`.
     */
    norm: (_context: Context, v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the Euclidean norm squared of the vector `v`.
     */
    normsq: (_context: Context, v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the Euclidean distance between the vectors `v` and `w`.
     */
    vdist: (_context: Context, v: ad.Num[], w: ad.Num[]) => FloatV<ad.Num>;
    vmul: (_context: Context, s: ad.Num, v: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Return the Euclidean distance squared between the vectors `v` and `w`.
     */
    vdistsq: (_context: Context, v: ad.Num[], w: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Return the angle made by the vector `v` with the positive x-axis.
     */
    angleOf: (_context: Context, v: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Base e of the natural logarithm.
     */
    MathE: (_context: Context) => FloatV<ad.Num>;
    /**
     * Ratio of the circumference of a circle to its diameter.
     */
    MathPI: (_context: Context) => FloatV<ad.Num>;
    /**
     * Rotate a 2D vector `v` by 90 degrees counterclockwise.
     */
    rot90: (_context: Context, v: ad.Num[]) => VectorV<ad.Num>;
    /**
     * Rotate a 2D vector `v` by theta degrees counterclockwise.
     */
    rotateBy: (_context: Context, v: ad.Num[], theta: ad.Num) => VectorV<ad.Num>;
    signedDistance: (_context: Context, [t, s]: [string, any], p: ad.Num[]) => FloatV<ad.Num>;
    /**
     * Construct a unit vector u in the direction of the
     * given angle theta (in radians).
     */
    unitVector: (_context: Context, theta: ad.Num) => VectorV<ad.Num>;
};
export declare const sdEllipse: (s: Ellipse, p: ad.Num[]) => ad.Num;
export declare const msign: (x: ad.Num) => ad.Num;
export declare const sdEllipseAsNums: (radiusx: ad.Num, radiusy: ad.Num, center: ad.Num[], pInput: ad.Num[]) => ad.Num;
export declare const checkComp: (fn: string, args: ArgVal<ad.Num>[]) => void;
//# sourceMappingURL=Functions.d.ts.map