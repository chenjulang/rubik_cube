import * as BBox from "../engine/BBox";
import { Ellipse } from "../shapes/Ellipse";
import * as ad from "../types/ad";
import { ImplicitEllipse } from "./ImplicitShapes";
/**
 * Compute coordinates of Minkowski sum of AABBs representing the first rectangle `box1` and the negative of the second rectangle `box2`.
 * Returns coordinates of the bottom left and top right corners.
 * Note: This is not the Minkowski difference in the classical sense, rather just a Minkowski sum of A and -B.
 * @param box1 First bounding box.
 * @param box2 Second bounding box.
 * @param padding Additional padding added to one of the boxes.
 */
export declare const rectangleDifference: (box1: BBox.BBox, box2: BBox.BBox, padding: ad.Num) => [ad.Pt2, ad.Pt2];
/**
 * Return value of the Signed Distance Function (SDF) of a half-plane evaluated at the origin.
 * @param lineSegment Two points defining a side of the first polygon.
 * @param otherPoints All vertices of the second polygon.
 * @param insidePoint Point inside of the half-plane.
 * @param padding Padding added to the half-plane.
 */
export declare const halfPlaneSDF: (lineSegment: ad.Num[][], otherPoints: ad.Num[][], insidePoint: ad.Num[], padding: ad.Num) => ad.Num;
/**
 * Return value of the Signed Distance Function (SDF) of the Minkowski sum of two polygons `p1` and `p2` evaluated at the origin.
 * @param p1 Sequence of points defining the first polygon.
 * @param p2 Sequence of points defining the second polygon.
 * @param padding Padding around the Minkowski sum.
 */
export declare const convexPolygonMinkowskiSDF: (p1: ad.Num[][], p2: ad.Num[][], padding: ad.Num) => ad.Num;
/**
 * Returns list of convex polygons comprising the original polygon. Assumes that
 * the polygon shape remains fixed after this function is called; that is, some
 * transformations can be applied, but vertices cannot change independently.
 * @param p Sequence of points defining a simple polygon.
 */
export declare const convexPartitions: (p: ad.Num[][]) => ad.Num[][][];
/**
 * Overlapping constraint function for polygon points with overlap `overlap`.
 * @param polygonPoints1 Sequence of points defining the first polygon.
 * @param polygonPoints2 Sequence of points defining the second polygon.
 * @param overlap Overlap applied to one of the polygons.
 */
export declare const overlappingPolygonPoints: (polygonPoints1: ad.Num[][], polygonPoints2: ad.Num[][], overlap?: ad.Num) => ad.Num;
/**
 * Returns the signed distance from a rectangle at the origin.
 */
export declare const rectangleSignedDistance: (bottomLeft: ad.Pt2, topRight: ad.Pt2) => ad.Num;
/**
 * Constraint checking whether `point` is inside a polygon with vertices `polygonPoints`.
 * @param polygonPoints Sequence of points defining a polygon.
 * @param point Testing point.
 * @param padding Padding applied to the polygon.
 */
export declare const containsPolygonPoints: (polygonPoints: ad.Num[][], point: ad.Num[], padding?: ad.Num) => ad.Num;
/**
 * Helper for Signed Distance Function (SDF) of a polygon and ellipse.
 * @param lineSegment Two points defining the line segment.
 * @param ellipse Ellipse shape.
 * @param insidePoint Any point inside of the half-plane.
 * @param padding Padding around the Minkowski sum.
 */
export declare const halfPlaneEllipseSDF: (lineSegment: ad.Num[][], ellipse: Ellipse, insidePoint: ad.Num[], padding: ad.Num) => ad.Num;
/**
 * Overlapping constraint function for of a polygon and ellipse.
 * @param polygonPoints Sequence of points defining a polygon.
 * @param ellipse Ellipse shape.
 * @param padding Padding applied to the ellipse.
 */
export declare const overlappingPolygonPointsEllipse: (polygonPoints: ad.Num[][], ellipse: Ellipse, padding: ad.Num) => ad.Num;
/**
 * Return candidates for extremal points of the implicit functions for ellipse-ellipse case.
 * @param ei1 Implicit ellipse parameters.
 * @param ei2 Implicit ellipse parameters.
 * @param lambda Solution to the quadratic formula.
 */
export declare const pointCandidatesEllipse: (ei1: ImplicitEllipse, ei2: ImplicitEllipse, lambda: ad.Num) => [ad.Num, ad.Num];
/**
 * Overlapping constraint function for two implicit ellipses.
 * @param ei1 First implicit ellipse.
 * @param ei2 Second implicit ellipse.
 */
export declare const overlappingImplicitEllipses: (ei1: ImplicitEllipse, ei2: ImplicitEllipse) => ad.Num;
//# sourceMappingURL=Minkowski.d.ts.map