import * as ad from "../types/ad";
export declare const constrDict: {
    /**
     * Make two intervals disjoint. They must be 1D intervals (line-like shapes) sharing a y-coordinate.
     */
    disjointIntervals: ([t1, s1]: [string, any], [t2, s2]: [string, any]) => ad.Num;
    /** Require that `shape` is on the canvas */
    onCanvas: ([shapeType, props]: any, canvasWidth: ad.Num, canvasHeight: ad.Num) => ad.Binary;
    /**
     * Require that a shape have a size greater than some constant minimum, based on the type of the shape.
     */
    minSize: ([shapeType, props]: [string, any], limit?: number) => ad.Binary;
    /**
     * Require that a shape have a size less than some constant maximum, based on the type of the shape.
     */
    maxSize: ([shapeType, props]: [string, any], limit: ad.Num) => ad.Binary;
    /**
     * Require that shape `s1` overlaps shape `s2` with some overlap `overlap`.
     * based on the type of the shape, and with an optional `overlap` between them
     * (e.g. if `s1` should be overlapping `s2` with margin `overlap`).
     */
    overlapping: ([t1, s1]: [string, any], [t2, s2]: [string, any], overlap?: ad.Num) => ad.Num;
    /**
     * Require that a shape `s1` is disjoint from shape `s2`,
     * based on the type of the shape, and with an optional `padding` between them
     * (e.g. if `s1` should be disjoint from `s2` with margin `padding`).
     */
    disjoint: ([t1, s1]: [string, any], [t2, s2]: [string, any], padding?: ad.Num) => ad.Unary;
    /**
     * Require that shape `s1` is touching shape `s2`.
     * based on the type of the shape, and with an optional `padding` between them
     * (e.g. if `s1` should be touching `s2` with margin `padding`).
     */
    touching: ([t1, s1]: [string, any], [t2, s2]: [string, any], padding?: ad.Num) => ad.Unary;
    /**
     * Require that a shape `s1` contains another shape `s2`,
     * based on the type of the shape, and with an optional `padding` between the sizes of the shapes
     * (e.g. if `s1` should contain `s2` with margin `padding`).
     */
    contains: ([t1, s1]: [string, any], [t2, s2]: [string, any], padding?: number) => ad.Num;
    /**
     * Require that shape `s1` is at a distance of `distance` from shape `s2`.
     */
    atDist: ([t1, s1]: [string, any], [t2, s2]: [string, any], distance: number) => ad.Num;
    /**
     * Require that shape `s1` is smaller than `s2` with some relative padding `relativePadding`.
     */
    smallerThan: ([t1, s1]: [string, any], [t2, s2]: [string, any], relativePadding?: number) => ad.Binary;
    /**
     * Require that the value `x` is equal to the value `y`
     */
    equal: (x: ad.Num, y: ad.Num) => ad.Unary;
    /**
     * Require that the value `x` is less than the value `y` with optional padding `padding`
     */
    lessThan: (x: ad.Num, y: ad.Num, padding?: number) => ad.Binary;
    /**
     * Require that the value `x` is greater than the value `y` with optional padding `padding`
     */
    greaterThan: (x: ad.Num, y: ad.Num, padding?: number) => ad.Binary;
    /**
     * Require that the value `x` is less than the value `y`, with steeper penalty
     */
    lessThanSq: (x: ad.Num, y: ad.Num) => ad.Ternary;
    /**
     * Require that the value `x` is greater than the value `y`, with steeper penalty
     */
    greaterThanSq: (x: ad.Num, y: ad.Num) => ad.Ternary;
    /**
     * Require that the value `x` is in the range defined by `[x0, x1]`.
     */
    inRange: (x: ad.Num, x0: ad.Num, x1: ad.Num) => ad.Binary;
    /**
     * Require that an interval `[l1, r1]` contains another interval `[l2, r2]`. If not possible, returns 0.
     */
    contains1D: ([l1, r1]: [ad.Num, ad.Num], [l2, r2]: [ad.Num, ad.Num]) => ad.Num;
    /**
     * Make scalar `c` disjoint from a range `left, right`.
     */
    disjointScalar: (c: ad.Num, left: ad.Num, right: ad.Num) => ad.Ternary;
    /**
     * Require that the vector defined by `(q, p)` is perpendicular from the vector defined by `(r, p)`.
     */
    perpendicular: (q: ad.Num[], p: ad.Num[], r: ad.Num[]) => ad.Num;
    /**
     * Require that three points be collinear.
     * Does not enforce a specific ordering of points, instead it takes the arrangement of points that is most easily satisfiable.
     */
    collinear: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => ad.Unary;
    /**
     * Require that three points be collinear.
     * Depends on the specific ordering of points.
     */
    collinearOrdered: (c1: ad.Num[], c2: ad.Num[], c3: ad.Num[]) => ad.Binary;
};
//# sourceMappingURL=Constraints.d.ts.map