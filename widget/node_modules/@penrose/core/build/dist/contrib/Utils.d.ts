import * as BBox from "../engine/BBox";
import * as ad from "../types/ad";
/**
 * Require that a shape at `center1` with radius `r1` not intersect a shape at `center2` with radius `r2` with optional padding `padding`. (For a non-circle shape, its radius should be half of the shape's general "width")
 */
export declare const noIntersectCircles: (center1: ad.Num[], r1: ad.Num, center2: ad.Num[], r2: ad.Num, padding?: number) => ad.Num;
/**
 * Return true iff `p` is in rect `b`.
 */
export declare const pointInBox: (p: ad.Pt2, rect: BBox.BBox) => ad.Bool;
/**
 * Helper function for atDist constraint.
 * If the point is outside the box, try to get the distance from the point to equal the desired distance.
 */
export declare const atDistOutside: (pt: ad.Pt2, rect: BBox.BBox, offset: ad.Num) => ad.Num;
/**
 * Return the amount of overlap between two intervals in R. (0 if none)
 */
export declare const overlap1D: ([l1, r1]: [ad.Num, ad.Num], [l2, r2]: [ad.Num, ad.Num]) => ad.Num;
/**
 * Return numerically-encoded boolean indicating whether `x \in [l, r]`.
 */
export declare const inRange: (x: ad.Num, l: ad.Num, r: ad.Num) => ad.Bool;
/**
 * Sample a line `line` at `NUM_SAMPLES` points uniformly.
 */
export declare const sampleSeg: (line: ad.Num[][]) => ad.Pt2[];
/**
 * Repel a vector `a` from a vector `b` with weight `c`.
 */
export declare const repelPoint: (c: ad.Num, a: ad.Num[], b: ad.Num[]) => ad.Num;
/**
 * Clamp `x` in range `[l, r]`.
 */
export declare const clamp: ([l, r]: [number, number], x: ad.Num) => ad.Num;
/**
 * Return the closest point on segment `[start, end]` to point `pt`.
 */
export declare const closestPt_PtSeg: (pt: ad.Num[], [start, end]: ad.Num[][]) => ad.Num[];
/**
 * Get numerical values of nodes in the computation graph. This function calls `secondaryGraph` to construct a partial computation graph and runs `genCode` to generate code to evaluate the values.
 *
 * @param xs nodes in the computation graph
 * @returns a list of `number`s corresponding to nodes in `xs`
 */
export declare const numsOf: (xs: ad.Num[]) => number[];
export declare const numOf: (x: ad.Num) => number;
//# sourceMappingURL=Utils.d.ts.map