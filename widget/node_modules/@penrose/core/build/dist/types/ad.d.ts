import { Outputs } from "@penrose/optimizer";
import GenericGraph from "../utils/Graph";
export type Expr = Bool | Num | Vec;
export type Bool = Comp | Logic | Not;
export type Num = number | Input | Unary | Binary | Ternary | Nary | Index;
export type Vec = PolyRoots;
export interface Input extends InputNode {
    val: number;
}
export interface Unary extends UnaryNode {
    param: Num;
}
export interface Binary extends BinaryNode {
    left: Num;
    right: Num;
}
export interface Comp extends CompNode {
    left: Num;
    right: Num;
}
export interface Logic extends LogicNode {
    left: Bool;
    right: Bool;
}
export interface Not extends NotNode {
    param: Bool;
}
export interface Ternary extends TernaryNode {
    cond: Bool;
    then: Num;
    els: Num;
}
export interface Nary extends NaryNode {
    params: Num[];
}
export interface PolyRoots extends PolyRootsNode {
    coeffs: Num[];
}
export interface Index extends IndexNode {
    vec: Vec;
}
export type Node = number | InputNode | UnaryNode | BinaryNode | CompNode | LogicNode | TernaryNode | NaryNode | PolyRootsNode | IndexNode | NotNode;
export interface InputNode {
    tag: "Input";
    key: number;
}
export interface UnaryNode {
    tag: "Unary";
    unop: "neg" | "squared" | "sqrt" | "inverse" | "abs" | "acosh" | "acos" | "asin" | "asinh" | "atan" | "atanh" | "cbrt" | "ceil" | "cos" | "cosh" | "exp" | "expm1" | "floor" | "log" | "log2" | "log10" | "log1p" | "round" | "sign" | "sin" | "sinh" | "tan" | "tanh" | "trunc";
}
export interface BinaryNode {
    tag: "Binary";
    binop: "+" | "*" | "-" | "/" | "max" | "min" | "atan2" | "pow";
}
export interface CompNode {
    tag: "Comp";
    binop: ">" | "<" | "===" | ">=" | "<=";
}
export interface NotNode {
    tag: "Not";
}
export interface LogicNode {
    tag: "Logic";
    binop: "&&" | "||";
}
export interface TernaryNode {
    tag: "Ternary";
}
export interface NaryNode {
    tag: "Nary";
    op: "addN" | "maxN" | "minN";
}
export interface PolyRootsNode {
    tag: "PolyRoots";
    degree: number;
}
export interface IndexNode {
    tag: "Index";
    index: number;
}
export type Edge = number;
export type Id = number;
export interface Graph extends Outputs<Id> {
    graph: GenericGraph<Id, Node, Edge>;
    nodes: Map<Expr, Id>;
}
export type Pt2 = [Num, Num];
export declare const isPt2: (vec: Num[]) => vec is Pt2;
//# sourceMappingURL=ad.d.ts.map