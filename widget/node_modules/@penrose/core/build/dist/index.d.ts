import { checkDomain, compileDomain, parseDomain } from "./compiler/Domain";
import { checkSubstance, compileSubstance, parseSubstance, prettySubstance } from "./compiler/Substance";
import { PathResolver, RenderInteractive, RenderShape, RenderStatic } from "./renderer/Renderer";
import { Canvas } from "./shapes/Samplers";
import { showMutations } from "./synthesis/Mutation";
import { Synthesizer } from "./synthesis/Synthesizer";
import { Env } from "./types/domain";
import { PenroseError } from "./types/errors";
import { Registry, Trio } from "./types/io";
import { Fn, State } from "./types/state";
import { SubProg } from "./types/substance";
import { Result, showError } from "./utils/Error";
import { bBoxDims, normList, prettyPrintExpr, prettyPrintFn, prettyPrintPath, toSvgPaintProperty } from "./utils/Util";
/**
 * Use the current resample seed to sample all shapes in the State.
 * @param state current state
 */
export declare const resample: (state: State) => State;
/**
 * Take n steps in the optimizer given the current state.
 * @param state current state
 * @param numSteps number of steps to take (default: 10000)
 */
export declare const stepState: (state: State, numSteps?: number) => State;
export declare const nextStage: (state: State) => State;
export declare const stepNextStage: (state: State, numSteps?: number) => State;
/**
 * Take n steps in the optimizer given the current state.
 * @param state current state
 * @param numSteps number of steps to take (default: 10000)
 */
export declare const stepStateSafe: (state: State, numSteps?: number) => Result<State, PenroseError>;
/**
 * Repeatedly take one step in the optimizer given the current state until convergence.
 * @param state current state
 */
export declare const stepUntilConvergence: (state: State, numSteps?: number) => Result<State, PenroseError>;
/**
 * Embed a static Penrose diagram in a DOM node.
 *
 * @param domainProg a Domain program string
 * @param subProg a Substance program string
 * @param styProg a Style program string
 * @param node a node in the DOM tree
 */
export declare const diagram: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
}, node: HTMLElement, pathResolver: PathResolver) => Promise<void>;
/**
 * Embed an interactive Penrose diagram in a DOM node.
 *
 * @param domainProg a Domain program string
 * @param subProg a Substance program string
 * @param styProg a Style program string
 * @param node a node in the DOM tree
 */
export declare const interactiveDiagram: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
}, node: HTMLElement, pathResolver: PathResolver) => Promise<void>;
/**
 * Given a trio of Domain, Substance, and Style programs, compile them into an initial `State`. Note that this function does _not_ evaluate the shapes. Generation of shapes is handled in `prepareState`.
 * @param domainProg a Domain program string
 * @param subProg a Substance program string
 * @param styProg a Style program string
 */
export declare const compileTrio: (prog: {
    substance: string;
    style: string;
    domain: string;
    variation: string;
}) => Promise<Result<State, PenroseError>>;
/**
 * Collect labels and images (if applicable).
 * @param state an initial diagram state
 */
export declare const prepareState: (state: State) => Promise<State>;
/**
 * Returns true if state is converged
 * @param state current state
 */
export declare const stateConverged: (state: State) => boolean;
/**
 * Returns true if the diagram state is on the last layout stage in the layout pipeline
 * @param state current state
 */
export declare const finalStage: (state: State) => boolean;
/**
 * Returns true if state is the initial frame
 * @param state current state
 */
export declare const stateInitial: (state: State) => boolean;
/**
 * Read and flatten the registry file for Penrose examples into a list of program trios.
 *
 * @param registry JSON file of the registry
 */
export declare const readRegistry: (registry: Registry) => Trio[];
/**
 * Evaluate the overall energy of a `State`. If the `State` does not have an optimization problem initialized (i.e. it doesn't have a defined `objectiveAndGradient` field), this function will call `genOptProblem` to initialize it. Otherwise, it will evaluate the cached objective function.
 * @param s a state with or without an optimization problem initialized
 * @returns a scalar value of the current energy
 */
export declare const evalEnergy: (s: State) => number;
/**
 * Evaluate a list of constraints/objectives: this will be useful if a user want to apply a subset of constrs/objs on a `State`. This function assumes that the state already has the objectives and constraints compiled.
 * @param fns a list of constraints/objectives
 * @param s a state with its opt functions cached
 * @returns a list of the energies of the requested functions, evaluated at the `varyingValues` in the `State`
 */
export declare const evalFns: (s: State) => {
    constrEngs: number[];
    objEngs: number[];
};
export type PenroseState = State;
export type PenroseFn = Fn;
export { constrDict } from "./contrib/Constraints";
export { compDict } from "./contrib/Functions";
export { objDict } from "./contrib/Objectives";
export { secondaryGraph } from "./engine/Autodiff";
export type { PathResolver } from "./renderer/Renderer";
export { makeCanvas, simpleContext } from "./shapes/Samplers";
export { shapedefs } from "./shapes/Shapes";
export type { SynthesizedSubstance, SynthesizerSetting, } from "./synthesis/Synthesizer";
export type { PenroseError } from "./types/errors";
export type { Shape } from "./types/shape";
export * as Value from "./types/value";
export type { Result } from "./utils/Error";
export { hexToRgba, rgbaToHex, zip2 } from "./utils/Util";
export { compileDomain, compileSubstance, checkDomain, checkSubstance, parseSubstance, parseDomain, Synthesizer, showMutations, RenderShape, RenderInteractive, RenderStatic, bBoxDims, prettySubstance, showError, prettyPrintFn, prettyPrintPath, prettyPrintExpr, normList, toSvgPaintProperty, };
export type { Registry, Trio };
export type { Env };
export type { SubProg };
export type { Canvas };
//# sourceMappingURL=index.d.ts.map