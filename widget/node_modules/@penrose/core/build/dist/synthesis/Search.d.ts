import rdiff from "recursive-diff";
import { Mutation, MutationGroup } from "./Mutation";
import { A, AbstractNode, Identifier } from "../types/ast";
import { Env, Type } from "../types/domain";
import { LabelOption, SubExpr, SubProg, SubStmt } from "../types/substance";
import { SynthesisContext } from "./Synthesizer";
type DiffType = AbstractNode["tag"];
export interface StmtDiff {
    diff: rdiff.rdiffResult;
    stmt: SubStmt<A>;
    diffType?: DiffType;
    originalValue: any;
}
export type SubDiff = UpdateDiff | AddDiff | DeleteDiff;
export interface DiffSet {
    add: AddDiff[];
    delete: DeleteDiff[];
    update: UpdateDiff[];
}
export interface UpdateDiff {
    diffType: "Update";
    source: SubStmt<A>;
    result: SubStmt<A>;
    rawDiff: rdiff.rdiffResult[];
    stmtDiff: StmtDiff[];
}
export interface AddDiff {
    diffType: "Add";
    source: SubStmt<A>;
}
export interface DeleteDiff {
    diffType: "Delete";
    source: SubStmt<A>;
}
/**
 * Compute the exact diffs between two Substance ASTs.
 *
 * @param left the original Substance program
 * @param right the changed Substance program
 * @returns a list of diffs
 */
export declare const diffSubProgs: (left: SubProg<A>, right: SubProg<A>) => rdiff.rdiffResult[];
/**
 * Compute statement-insensitive diffs between two Substance ASTs.
 *
 * @param left the original Substance program
 * @param right the changed Substance program
 * @returns a list of diffs tagged with the original statement
 */
export declare const diffSubStmts: (left: SubProg<A>, right: SubProg<A>) => StmtDiff[];
export type SubNode<T> = LabelOption<T> | SubExpr<T> | SubProg<T> | SubStmt<T> | Type<T>;
/**
 * Determine if two Substance AST nodes are similar. The metric is whether the nodes have common descendents or are equal themselves.
 *
 * @param left a node in the Substance AST
 * @param right a node in the Substance AST
 * @returns if the nodes have common descendents
 */
export declare const similarNodes: (left: SubNode<A>, right: SubNode<A>) => boolean;
interface SimilarMapping {
    source: SubStmt<A>;
    similarStmts: SubStmt<A>[];
}
export declare const subProgDiffs: (left: SubProg<A>, right: SubProg<A>) => DiffSet;
export declare const showSubDiff: (d: SubDiff) => string;
export declare const showDiffset: (d: DiffSet) => string;
export declare const updateDiffs: (mappings: SimilarMapping[]) => UpdateDiff[];
/**
 * For each statement in `leftSet`, find out similar statements in `rightSet`.
 *
 * @param leftSet the first set of statements
 * @param rightSet the second set of statements
 * @returns
 */
export declare const similarMappings: (leftSet: SubStmt<A>[], rightSet: SubStmt<A>[]) => SimilarMapping[];
export declare const rawToStmtDiff: (diff: rdiff.rdiffResult, source: SubStmt<A>) => StmtDiff;
export declare const toStmtDiff: (diff: rdiff.rdiffResult, ast: SubProg<A>) => StmtDiff;
export declare const showStmtDiff: (d: StmtDiff) => string;
export declare const applyStmtDiff: (prog: SubProg<A>, stmtDiff: StmtDiff) => SubProg<A>;
export declare const swapDiffID: (d: StmtDiff, id: Identifier<A>) => StmtDiff;
/**
 * Apply a set of statement diffs on a Substance program.
 * NOTE: instead of sequencially applying each diff, we find all applicable diffs and apply them in a batch for each Substance statement
 *
 * @param prog the origianl Substance program
 * @param diffs a set of diffs to apply
 * @returns
 */
export declare const applyStmtDiffs: (prog: SubProg<A>, diffs: StmtDiff[]) => SubProg<A>;
export declare const findDiffs: (stmt: SubStmt<A>, diffs: StmtDiff[]) => rdiff.rdiffResult[];
export declare const cartesianProduct: <T>(...sets: T[][]) => T[][];
/**
 * Given two Substance programs, find possible mutation paths that transform from `src` to `dest`.
 *
 * @param src The source Substance program
 * @param dest The changed Substance program
 * @param srcEnv The environment for the source Substance program
 */
export declare const findMutationPaths: (src: SubProg<A>, dest: SubProg<A>, srcEnv: Env) => MutationGroup[];
export declare const enumerateAllPaths: (src: SubProg<A>, dest: SubProg<A>, srcEnv: Env) => MutationGroup[];
interface MutatedSubProg {
    prog: SubProg<A>;
    cxt: SynthesisContext;
    mutations: Mutation[];
}
/**
 * @param srcProg the source Substance program
 * @param destStmt the result Substance program
 * @param initCxt the current synthesis context
 * @param maxDepth maximum number of mutations per path
 * @returns a list of mutation paths that tranform from `srcStmt` to `destStmt`, up to `maxDepth`
 */
export declare const enumerateMutationPaths: (srcProg: SubProg<A>, destProg: SubProg<A>, initCxt: SynthesisContext, maxDepth: number) => MutatedSubProg[];
export {};
//# sourceMappingURL=Search.d.ts.map