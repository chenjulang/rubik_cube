import { ArgStmtDecl, SubStmtKind } from "../analysis/SubstanceAnalysis";
import im from "immutable";
import seedrandom from "seedrandom";
import { Mutation, MutationGroup } from "./Mutation";
import { A, Identifier } from "../types/ast";
import { DomainStmt, Env } from "../types/domain";
import { ApplyPredicate, Bind, SubExpr, SubPredArg, SubProg, SubRes, SubStmt } from "../types/substance";
type All = "*";
type ArgOption = "existing" | "generated" | "mixed";
type ArgReuse = "distinct" | "repeated";
type MatchSetting = string[] | All;
type DeclTypes = {
    [t in SubStmtKind]: MatchSetting;
};
export interface SynthesizerSetting {
    mutationCount: [number, number];
    argOption: ArgOption;
    argReuse: ArgReuse;
    weights: {
        type: number;
        predicate: number;
        constructor: number;
    };
    add: DeclTypes;
    delete: DeclTypes;
    edit: DeclTypes;
}
export interface SynthesisContext {
    names: im.Map<string, number>;
    declaredIDs: im.Map<string, Identifier<A>[]>;
    generatedNames: im.Map<string, number>;
    argOption: ArgOption;
    argReuse: ArgReuse;
    env: Env;
    choice: <T>(array: Array<T>) => T;
}
export interface SynthesizedSubstance {
    prog: SubProg<A>;
    ops: Mutation[];
}
export declare const initContext: (env: Env, argOption: ArgOption, argReuse: ArgReuse, randomSeed: string) => SynthesisContext;
export declare const filterContext: (ctx: SynthesisContext, setting: DeclTypes) => SynthesisContext;
export declare const showEnv: (env: Env) => string;
/**
 * Add a newly declared ID.
 *
 * NOTE: this should be called whenever we add a `Decl`
 * statement from list of statements to keep them in sync.
 * @param typeStr the type associated with the ID
 * @param id the identifier that is being removed
 */
export declare const addID: (ctx: SynthesisContext, typeStr: string, id: Identifier<A>) => SynthesisContext;
/**
 * Remove a declared ID.
 *
 * NOTE: this should be called whenever we delete a `Decl`
 * statement from list of statements to keep them in sync.
 * @param typeStr the type associated with the ID
 * @param id the identifier that is being removed
 */
export declare const removeID: (ctx: SynthesisContext, typeStr: string, id: Identifier<A>) => SynthesisContext;
interface WithStmts<T> {
    res: T;
    ctx: SynthesisContext;
    stmts: SubStmt<A>[];
}
export interface WithContext<T> {
    res: T;
    ctx: SynthesisContext;
}
export declare class Synthesizer {
    env: Env;
    template: SubProg<A>;
    setting: SynthesizerSetting;
    currentProg: SubProg<A>;
    currentMutations: Mutation[];
    rng: seedrandom.prng;
    private choice;
    private random;
    constructor(env: Env, setting: SynthesizerSetting, subRes?: SubRes, seed?: string);
    reset: () => void;
    showMutations: () => string;
    updateProg: (prog: SubProg<A>) => void;
    getTemplate: () => SubProg<A> | undefined;
    /**
     * Top-level function for generating multiple Substance programs.
     * @param numProgs number of Substance programs to generate
     * @returns an array of Substance programs and some metadata (e.g. mutation operation record)
     */
    generateSubstances: (numProgs: number) => SynthesizedSubstance[];
    generateSubstance: () => SynthesizedSubstance;
    /**
     * Find a list of possible mutations for the current Substance program stored in the context, and execute one of the mutations.
     */
    mutateProgram: (ctx: SynthesisContext) => SynthesisContext;
    findMutations: (stmt: SubStmt<A>, ctx: SynthesisContext) => MutationGroup[];
    /**
     * Pick a random statement in the Substance program and enumerate all the applicable mutations.
     * @returns a list of mutation groups, each representing a series of `Update` mutations
     */
    enumerateUpdate: (ctx: SynthesisContext) => MutationGroup[];
    /**
     * From the configuration, pick one Substance construct to generate, and return the new construct along with all other related constructs as a group of `Add` mutations.
     * @returns a group of `Add` mutations
     */
    enumerateAdd: (ctx: SynthesisContext) => MutationGroup;
    /**
     * From the configuration, pick one Substance statement to delete, and return one or more `Delete` mutations depending on if there will be cascading delete.
     * @returns a group of `Delete` mutations
     */
    enumerateDelete: (ctx: SynthesisContext) => MutationGroup;
    findStmt: (stmtType: DomainStmt<A>["tag"], name: string) => SubStmt<A> | undefined;
}
export declare const generateArgStmt: (decl: ArgStmtDecl<A>, ctx: SynthesisContext, args?: SubExpr<A>[] | SubPredArg<A>[]) => WithStmts<Bind<A> | ApplyPredicate<A>>;
export {};
//# sourceMappingURL=Synthesizer.d.ts.map