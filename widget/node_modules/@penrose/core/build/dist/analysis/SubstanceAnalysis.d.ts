import im from "immutable";
import { A, AbstractNode, C, Identifier } from "../types/ast";
import { ConstructorDecl, DomainStmt, Env, FunctionDecl, PredicateDecl, TypeDecl } from "../types/domain";
import { ApplyConstructor, ApplyFunction, ApplyPredicate, AutoLabel, Bind, Decl, Func, SubExpr, SubPredArg, SubProg, SubStmt, TypeConsApp } from "../types/substance";
export interface Signature {
    args: string[];
    output?: string;
}
export type ArgStmtDecl<T> = PredicateDecl<T> | FunctionDecl<T> | ConstructorDecl<T>;
export type ArgStmt<T> = ApplyFunction<T> | ApplyPredicate<T> | ApplyConstructor<T>;
export type ArgExpr<T> = ApplyFunction<T> | ApplyConstructor<T> | Func<T>;
/**
 * Append a statement to a Substance program
 *
 * @param prog a Substance program
 * @param stmt a statement to append
 * @returns a new Substance program
 */
export declare const appendStmt: (prog: SubProg<A>, stmt: SubStmt<A>) => SubProg<A>;
/**
 * Find all declarations that take the same number and type of args as
 * original statement
 * @param stmt a Substance statement
 * @param env Env of the program
 * @returns a new Substance statement
 */
export declare const argMatches: (stmt: ApplyConstructor<A> | ApplyPredicate<A> | ApplyFunction<A> | Func<A> | Bind<A>, env: Env) => ArgStmtDecl<C>[];
/**
 * Remove a statement from a Substance program.
 * NOTE: When the statement doesn't exist in the program, `removeStmt` returns the original program without errors.
 *
 * @param prog a Substance program
 * @param stmt a statement to delete
 * @returns a new Substance program with the statement removed
 */
export declare const removeStmt: <T>(prog: SubProg<T>, stmt: SubStmt<T>) => SubProg<T>;
/**
 * Replace a statement in a Substance program.
 * NOTE: When the statement to replace doesn't exist in the program, `replaceStmt` returns the original program without errors.
 *
 * @param prog a Substance program
 * @param originalStmt a statement to remove
 * @param newStmt a statement to add in place of the removed statement
 * @returns a new Substance program with the statement replaced
 */
export declare const replaceStmt: <T>(prog: SubProg<T>, originalStmt: SubStmt<T>, newStmt: SubStmt<T>) => SubProg<T>;
/**
 * Get a Substance statement by index
 *
 * @param prog a Substance program
 * @param index the index of a Substance statement in the program
 * @returns
 */
export declare const getStmt: <T>(prog: SubProg<T>, index: number) => SubStmt<T>;
/**
 * Find all signatures that match a reference statement. NOTE: returns an empty list if
 * no matches are found; does not include the reference statement in list of matches.
 *
 * @param stmtName string value of a statement, i.e. "isSubset"
 * @param opts all possible declaration options
 * @param matchFunc function that determines condition for a match
 * @returns Array of any statements that have the same signature as input statement
 */
export declare const matchDecls: <T>(stmt: ArgStmtDecl<T>, opts: im.Map<string, ArgStmtDecl<T>>, matchFunc: (a: Signature, b: Signature) => boolean) => ArgStmtDecl<T>[];
/**
 * Find a given statement's declaration from Domain.
 * NOTE: match will be undefined if the statement could not
 * be found in list of predicates, functions, or constructors
 *
 * @param stmtName string value of a statement, i.e. "isSubset"
 * @param env Env for current program
 * @returns Array of length 2, with entries corresponding to: [matching decl, list where decl was found]
 */
export declare const findDecl: (stmtName: string, env: Env) => [ArgStmtDecl<C> | undefined, im.Map<string, ArgStmtDecl<C>>];
/**
 * Find matching signatures for a given statement
 *
 * @param stmt any supported Statement object (constructor, predicate, function)
 * @param env an Env object with domain/substance metadata
 * @param editType the type of edit mutation occurring
 * @returns an Array of all other statements that match the stmt signature
 */
export declare const matchSignatures: (stmt: ApplyConstructor<A> | ApplyPredicate<A> | ApplyFunction<A> | Func<A>, env: Env) => ArgStmtDecl<C>[];
/**
 * Get signature of a declaration
 *
 * @param decl a Declaration object
 * @returns a new Signature object
 */
export declare const getSignature: (decl: ArgStmtDecl<A>) => Signature;
/**
 * Check if 2 signatures are equal
 *
 * @param a a Signature
 * @param b a Signature
 * @returns true if signatures are equal
 */
export declare const signatureEquals: (a: Signature, b: Signature) => boolean;
/**
 * Check if the types of 2 signatures' arguments are equal
 *
 * @param a a Signature
 * @param b a Signature
 * @returns true if signatures take the same number and type of args
 */
export declare const signatureArgsEqual: (a: Signature, b: Signature) => boolean;
/**
 * Map each of a statement's parameters to all of its possible swap-in replacements
 * NOTE: if there are no valid swaps, returns an empty map
 *
 * @param ids a Substance statement's arguments
 * @param env the current environment
 * @returns a map of statement argument -> valid swap-in options
 */
export declare const identicalTypeDecls: (ids: Identifier<A>[], env: Env) => im.Map<string, Identifier<A>[]>;
/**
 * Given a statement which returns a value
 * that is staged to be deleted, iteratively find any other
 * statements that would use the statement's returned variable
 *
 * @param dec either a `Bind` or `Decl` that is staged to be deleted
 * @param prog the Substance program
 * @returns a list of statements to be deleted
 */
export declare const cascadingDelete: <T>(dec: Bind<T> | Decl<T>, prog: SubProg<T>) => SubStmt<T>[];
export declare const printStmts: (stmts: PredicateDecl<A>[] | ConstructorDecl<A>[] | FunctionDecl<A>[]) => void;
export declare const domainToSubType: (domainType: DomainStmt<A>["tag"]) => Decl<A>["tag"] | ApplyPredicate<A>["tag"] | ApplyFunction<A>["tag"] | ApplyConstructor<A>["tag"] | Func<A>["tag"] | undefined;
export declare const applyConstructor: (decl: ConstructorDecl<A>, args: SubExpr<A>[]) => ApplyConstructor<A>;
export declare const applyFunction: (decl: FunctionDecl<A>, args: SubExpr<A>[]) => ApplyFunction<A>;
export declare const applyPredicate: (decl: PredicateDecl<A>, args: SubPredArg<A>[]) => ApplyPredicate<A>;
export declare const subProg: (statements: SubStmt<A>[]) => SubProg<A>;
export declare const applyTypeDecl: (decl: TypeDecl<A>) => TypeConsApp<A>;
export declare const applyBind: (variable: Identifier<A>, expr: SubExpr<A>) => Bind<A>;
export declare const nullaryTypeCons: (name: Identifier<A>) => TypeConsApp<A>;
export declare const autoLabelStmt: AutoLabel<A>;
/**
 * Compare two AST nodes by their contents, ignoring structural properties such as `nodeType` and positional properties like `start` and `end`.
 *
 * @param node1 the first AST node
 * @param node2 the second AST node
 * @returns a boolean value
 */
export declare const nodesEqual: (node1: AbstractNode, node2: AbstractNode) => boolean;
/**
 * Compare all statements of two ASTs by their contents, ignoring structural properties such as `nodeType` and positional properties like `start` and `end`.
 *
 * @param left the first Substance program
 * @param right the second Substance program
 * @returns a boolean value
 */
export declare const progsEqual: <T>(left: SubProg<T>, right: SubProg<T>) => boolean;
/**
 * Find all common statements between `left` and `right` Substance programs.
 * @param left the first Substance program
 * @param right the second Substance program
 * @returns a list of Substacne statements
 */
export declare const intersection: <T>(left: SubProg<T>, right: SubProg<T>) => SubStmt<T>[];
/**
 * Sort the statements in a Substance AST by statement type and then by lexicographic ordering of source text.
 * @param prog A Substance AST
 * @returns A sorted Substance AST
 */
export declare const sortStmts: <T>(prog: SubProg<T>) => SubProg<T>;
export declare const stmtExists: (stmt: SubStmt<A>, prog: SubProg<A>) => boolean;
export declare const cleanNode: (prog: AbstractNode) => AbstractNode;
/**
 * Finds the type of a Substance identifer.
 *
 * @param id an identifer
 * @param env the environment
 * @returns
 */
export declare const typeOf: (id: string, env: Env) => string | undefined;
export type SubStmtKind = "type" | "predicate" | "constructor" | "function";
type SubStmtKindMap = {
    [t in SubStmtKind]: string[];
};
/**
 * Given a Substance program, find out the types, constructors, functions, and predicates used in the program.
 */
export declare const findTypes: <T>(prog: SubProg<T>) => SubStmtKindMap;
export declare const mergeKindMaps: (m1: SubStmtKindMap, m2: SubStmtKindMap) => SubStmtKindMap;
export {};
//# sourceMappingURL=SubstanceAnalysis.d.ts.map