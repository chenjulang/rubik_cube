import * as ad from "../types/ad";
/**
 * Return `v + w`.
 */
export declare const add: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return the sum of elements in `xs`.
 */
export declare const addN: (xs: ad.Num[]) => ad.Num;
/**
 * Return `v * w`.
 */
export declare const mul: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `v - w`.
 */
export declare const sub: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `v / w`.
 */
export declare const div: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `max(v, w)`.
 */
export declare const max: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `min(v, w)`.
 */
export declare const min: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `maxN(xs)`.
 */
export declare const maxN: (xs: ad.Num[]) => ad.Num;
/**
 * Return `minN(xs)`.
 */
export declare const minN: (xs: ad.Num[]) => ad.Num;
/**
 * Returns the two-argument arctangent `atan2(y, x)`, which
 * describes the angle made by a vector (x,y) with the x-axis.
 * Returns a value in radians, in the range [-pi,pi].
 */
export declare const atan2: (y: ad.Num, x: ad.Num) => ad.Binary;
/**
 * Returns `pow(v,w)`.
 */
export declare const pow: (v: ad.Num, w: ad.Num) => ad.Binary;
/**
 * Return `-v`.
 */
export declare const neg: (v: ad.Num) => ad.Unary;
/**
 * Return `v * v`.
 */
export declare const squared: (v: ad.Num) => ad.Unary;
/**
 * Return `sqrt(v)`.
 */
export declare const sqrt: (v: ad.Num) => ad.Unary;
/**
 * Return `1 / v`.
 */
export declare const inverse: (v: ad.Num) => ad.Unary;
/**
 * Return `|v|`.
 */
export declare const absVal: (v: ad.Num) => ad.Unary;
/**
 * Return `acosh(v)`.
 */
export declare const acosh: (v: ad.Num) => ad.Unary;
/**
 * Return `acos(v)`.
 */
export declare const acos: (v: ad.Num) => ad.Unary;
/**
 * Return `asin(v)`.
 */
export declare const asin: (v: ad.Num) => ad.Unary;
/**
 * Return `asinh(v)`.
 */
export declare const asinh: (v: ad.Num) => ad.Unary;
/**
 * Return `atan(v)`.
 */
export declare const atan: (v: ad.Num) => ad.Unary;
/**
 * Return `atanh(v)`.
 */
export declare const atanh: (v: ad.Num) => ad.Unary;
/**
 * Return `cbrt(v)`.
 */
export declare const cbrt: (v: ad.Num) => ad.Unary;
/**
 * Return `ceil(v)`.
 */
export declare const ceil: (v: ad.Num) => ad.Unary;
/**
 * Return `cos(v)`.
 */
export declare const cos: (v: ad.Num) => ad.Unary;
/**
 * Return `cosh(v)`.
 */
export declare const cosh: (v: ad.Num) => ad.Unary;
/**
 * Return `exp(v)`.
 */
export declare const exp: (v: ad.Num) => ad.Unary;
/**
 * Return `expm1(v)`.
 */
export declare const expm1: (v: ad.Num) => ad.Unary;
/**
 * Return `floor(v)`.
 */
export declare const floor: (v: ad.Num) => ad.Unary;
/**
 * Return the natural logarithm `ln(v)` (i.e., log base e).
 */
export declare const ln: (v: ad.Num) => ad.Unary;
/**
 * Return `log2(v)`.
 */
export declare const log2: (v: ad.Num) => ad.Unary;
/**
 * Return `log10(v)`.
 */
export declare const log10: (v: ad.Num) => ad.Unary;
/**
 * Return `log1p(v)`.
 */
export declare const log1p: (v: ad.Num) => ad.Unary;
/**
 * Return `round(v)`.
 */
export declare const round: (v: ad.Num) => ad.Unary;
/**
 * Return `sign(v)`.
 */
export declare const sign: (v: ad.Num) => ad.Unary;
/**
 * Return `sin(v)`.
 */
export declare const sin: (v: ad.Num) => ad.Unary;
/**
 * Return `sinh(v)`.
 */
export declare const sinh: (v: ad.Num) => ad.Unary;
/**
 * Return `tan(v)`.
 */
export declare const tan: (v: ad.Num) => ad.Unary;
/**
 * Return `tanh(v)`.
 */
export declare const tanh: (v: ad.Num) => ad.Unary;
/**
 * Return `trunc(v)`.
 */
export declare const trunc: (v: ad.Num) => ad.Unary;
/**
 * Return a conditional `v > w`.
 */
export declare const gt: (v: ad.Num, w: ad.Num) => ad.Comp;
/**
 * Return a conditional `v < w`.
 */
export declare const lt: (v: ad.Num, w: ad.Num) => ad.Comp;
/**
 * Return a conditional `v >= w`.
 */
export declare const gte: (v: ad.Num, w: ad.Num) => ad.Comp;
/**
 * Return a conditional `v <= w`.
 */
export declare const lte: (v: ad.Num, w: ad.Num) => ad.Comp;
/**
 * Return a conditional `v == w`. (TODO: Maybe check if they are equal up to a tolerance?)
 */
export declare const eq: (v: ad.Num, w: ad.Num) => ad.Comp;
/**
 * Return a boolean `v && w`
 */
export declare const and: (v: ad.Bool, w: ad.Bool) => ad.Logic;
/**
 * Return a boolean `v || w`
 */
export declare const or: (v: ad.Bool, w: ad.Bool) => ad.Logic;
export declare const not: (v: ad.Bool) => ad.Not;
/**
 * Return a conditional `if(cond) then v else w`.
 */
export declare const ifCond: (cond: ad.Bool, v: ad.Num, w: ad.Num) => ad.Ternary;
/**
 * Return the roots of the monic polynomial with degree `coeffs.length` where
 * the coefficient on the term with degree `i` is `coeffs[i]`. Any root with a
 * nonzero imaginary component is replaced with `NaN`.
 */
export declare const polyRoots: (coeffs: ad.Num[]) => ad.Num[];
//# sourceMappingURL=AutodiffFunctions.d.ts.map