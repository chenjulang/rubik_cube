import { Gradient } from "@penrose/optimizer";
import { InputMeta } from "../shapes/Samplers";
import * as ad from "../types/ad";
import { A, ASTNode, ConcreteNode, Identifier, NodeType, SourceLoc } from "../types/ast";
import { StyleError } from "../types/errors";
import { ShapeAD } from "../types/shape";
import { ShapeFn } from "../types/state";
import { Expr, Path } from "../types/style";
import { PropID, ShapeTypeStr, Value } from "../types/value";
export declare const wrapErr: (s: string) => StyleError;
export declare const runtimeValueTypeError: (path: Path<A>, expectedType: string, actualType: string) => StyleError;
export declare function mapTuple<T, S>(f: (arg: T) => S, t: T[]): S[];
export declare function mapTupNested<T, S>(f: (arg: T) => S, t: T[][]): S[][];
export declare function mapValueNumeric<T, S>(f: (arg: T) => S, v: Value<T>): Value<S>;
export declare const compileCompGraph: (shapes: ShapeAD[]) => Promise<ShapeFn>;
/**
 * Generate an energy function from the current state (using `ad.Num`s only)
 */
export declare const genGradient: (inputs: InputMeta[], objEngs: ad.Num[], constrEngs: ad.Num[]) => Promise<Gradient>;
export declare const dummySourceLoc: () => SourceLoc;
export declare const isConcrete: (node: ASTNode<A>) => node is ConcreteNode;
export declare const dummyIdentifier: (name: string, nodeType: NodeType) => Identifier<A>;
export declare const propertiesOf: (propType: string, shapeType: ShapeTypeStr) => PropID[];
export declare const propertiesNotOf: (propType: string, shapeType: ShapeTypeStr) => PropID[];
export declare const exprToNumber: (e: Expr<A>) => number;
//# sourceMappingURL=EngineUtils.d.ts.map