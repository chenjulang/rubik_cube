import { Gradient, Outputs } from "@penrose/optimizer";
import * as ad from "../types/ad";
import Graph from "../utils/Graph";
export declare const logAD: import("consola").Consola;
export declare const EPS_DENOM = 0.00001;
export declare const input: ({ key, val }: Omit<ad.Input, "tag">) => ad.Input;
/**
 * Construct an explicit graph from a primary output and array of secondary
 * outputs. All out-edges relevant to computing the gradient can be considered
 * totally ordered, first by the node the edge points to (where the nodes are
 * numbered by doing a breadth-first search from the primary output using the
 * `children` function) and then by the name of the edge (again according to the
 * order given by the `children` function). The partial derivatives contributing
 * to any given gradient node are added up according to that total order.
 */
export declare const makeGraph: (outputs: Omit<Outputs<ad.Num>, "gradient">) => ad.Graph;
/**
 * Construct a graph with a primary output but no secondary outputs.
 */
export declare const primaryGraph: (output: ad.Num) => ad.Graph;
/**
 * Construct a graph from an array of only secondary outputs, for which we don't
 * care about the gradient. The primary output is just the constant 1.
 */
export declare const secondaryGraph: (outputs: ad.Num[]) => ad.Graph;
/**
 * Some vector operations that can be used on `ad.Num`.
 */
export declare const ops: {
    /**
     * Return the norm of the 2-vector `[c1, c2]`.
     */
    norm: (c1: ad.Num, c2: ad.Num) => ad.Num;
    /**
     * Return the Euclidean distance between scalars `c1, c2`.
     */
    dist: (c1: ad.Num, c2: ad.Num) => ad.Num;
    /**
     * Return the sum of vectors `v1, v2.
     */
    vadd: (v1: ad.Num[], v2: ad.Num[]) => ad.Num[];
    /**
     * Return the difference of vectors `v1` and `v2`.
     */
    vsub: (v1: ad.Num[], v2: ad.Num[]) => ad.Num[];
    /**
     * Return the Euclidean norm squared of vector `v`.
     */
    vnormsq: (v: ad.Num[]) => ad.Num;
    /**
     * Return the Euclidean norm of vector `v`.
     */
    vnorm: (v: ad.Num[]) => ad.Num;
    /**
     * Return the vector `v` multiplied by scalar `c`.
     */
    vmul: (c: ad.Num, v: ad.Num[]) => ad.Num[];
    /**
     * Returns the entrywise product of two vectors, `v1` and `v2`
     */
    vproduct: (v1: ad.Num[], v2: ad.Num[]) => ad.Num[];
    /**
     * Return the entrywise absolute value of the vector `v`
     */
    vabs: (v: ad.Num[]) => ad.Num[];
    /**
     * Return the maximum value of each component of the vectors `v1` and `v2`
     */
    vmax: (v1: ad.Num[], v2: ad.Num[]) => ad.Num[];
    /**
     * Return the vector `v`, scaled by `-1`.
     */
    vneg: (v: ad.Num[]) => ad.Num[];
    /**
     * Return the vector `v` divided by scalar `c`.
     */
    vdiv: (v: ad.Num[], c: ad.Num) => ad.Num[];
    /**
     * Return the vector `v`, normalized.
     */
    vnormalize: (v: ad.Num[]) => ad.Num[];
    /**
     * Return the Euclidean distance between vectors `v` and `w`.
     */
    vdist: (v: ad.Num[], w: ad.Num[]) => ad.Num;
    /**
     * Return the Euclidean distance squared between vectors `v` and `w`.
     */
    vdistsq: (v: ad.Num[], w: ad.Num[]) => ad.Num;
    /**
     * Return the dot product of vectors `v1, v2`.
     * Note: if you want to compute a norm squared, use `vnormsq` instead, it generates a smaller computational graph
     */
    vdot: (v1: ad.Num[], v2: ad.Num[]) => ad.Num;
    /**
     * Return the unsigned angle between vectors `u, v`, in radians.
     * Assumes that both u and v have nonzero magnitude.
     * The returned value will be in the range [0,pi].
     */
    angleBetween: (u: ad.Num[], v: ad.Num[]) => ad.Num;
    /**
     * Return the signed angle from vector `u` to vector `v`, in radians.
     * Assumes that both u and v are 2D vectors and have nonzero magnitude.
     * The returned value will be in the range [-pi,pi].
     */
    angleFrom: (u: ad.Num[], v: ad.Num[]) => ad.Num;
    /**
     * Return the sum of elements in vector `v`.
     */
    vsum: (v: ad.Num[]) => ad.Num;
    /**
     * Return `v + c * u`.
     */
    vmove: (v: ad.Num[], c: ad.Num, u: ad.Num[]) => ad.Num[];
    /**
     * Rotate a 2D point `[x, y]` by 90 degrees counterclockwise.
     */
    rot90: ([x, y]: ad.Num[]) => ad.Num[];
    /**
     * Rotate a 2D point `[x, y]` by a degrees counterclockwise.
     */
    vrot: ([x, y]: ad.Num[], a: ad.Num) => ad.Num[];
    /**
     * Return 2D determinant/cross product of 2D vectors
     */
    cross2: (u: ad.Num[], v: ad.Num[]) => ad.Num;
    /**
     * Return 3D cross product of 3D vectors
     */
    cross3: (u: ad.Num[], v: ad.Num[]) => ad.Num[];
};
export declare const fns: {
    /**
     * Return the penalty `max(x, 0)`.
     */
    toPenalty: (x: ad.Num) => ad.Num;
    /**
     * Return the center of a shape.
     */
    center: (props: any) => ad.Num[];
};
/**
 * Compile an array of graphs into a function to compute the sum of their
 * primary outputs. The gradients are also summed. The keys present in the
 * secondary outputs must be disjoint; they all go into the same array, so the
 * expected secondary outputs would be ambiguous if keys were shared.
 * @param graphs an array of graphs to compile
 * @returns a compiled/instantiated WebAssembly function
 */
export declare const genCode: (...graphs: ad.Graph[]) => Promise<Gradient>;
/**
 * Synchronous version of `genCode`. Should not be used in the browser because
 * this will fail if the generated module is larger than 4 kilobytes, but
 * currently is used in convex partitioning for convenience.
 */
export declare const genCodeSync: (...graphs: ad.Graph[]) => Gradient;
//# sourceMappingURL=Autodiff.d.ts.map