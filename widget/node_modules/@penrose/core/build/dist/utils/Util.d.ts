import seedrandom from "seedrandom";
import { LineProps } from "../shapes/Line";
import { ShapeType } from "../shapes/Shapes";
import * as ad from "../types/ad";
import { A } from "../types/ast";
import { Either, Left, Right } from "../types/common";
import { Properties } from "../types/shape";
import { Fn } from "../types/state";
import { BindingForm, Expr, Path } from "../types/style";
import { Context, ResolvedName, ResolvedPath } from "../types/styleSemantics";
import { BoolV, Color, ColorV, FloatV, ListV, LListV, MatrixV, PathCmd, PathDataV, PtListV, StrV, TupV, Val, Value, VectorV } from "../types/value";
/**
 * Safe wrapper for any function that might return `undefined`.
 * @borrows https://stackoverflow.com/questions/54738221/typescript-array-find-possibly-undefind
 * @param argument Possible unsafe function call
 * @param message Error message
 */
export declare const safe: <T extends unknown>(argument: T | undefined, message: string) => T;
export declare const repeat: <T>(i: number, x: T) => T[];
export declare const all: (xs: boolean[]) => boolean;
/**
 * Like _.zip but throws on different length instead of padding with undefined.
 */
export declare const zip2: <T1, T2>(a1: T1[], a2: T2[]) => [T1, T2][];
/**
 * Like _.zip but throws on different length instead of padding with undefined.
 */
export declare const zip3: <T1, T2, T3>(a1: T1[], a2: T2[], a3: T3[]) => [T1, T2, T3][];
/**
 * Generate a random float. The maximum is exclusive and the minimum is inclusive
 * @param min minimum (inclusive)
 * @param max maximum (exclusive)
 */
export declare const randFloats: (rng: seedrandom.prng, count: number, [min, max]: [number, number]) => number[];
/**
 * Generate a random float. The maximum is exclusive and the minimum is inclusive
 * @param min minimum (inclusive)
 * @param max maximum (exclusive)
 */
export declare const randFloat: (rng: seedrandom.prng, min: number, max: number) => number;
export declare const randList: (rng: seedrandom.prng, n: number) => number[];
export interface ArrowheadSpec {
    width: number;
    height: number;
    viewbox: string;
    refX: number;
    refY: number;
    path: string;
    fillKind: "stroke" | "fill";
    style?: {
        [k: string]: string;
    };
}
type ArrowheadMap = {
    [k: string]: ArrowheadSpec;
};
export declare const arrowheads: ArrowheadMap;
export declare const getArrowhead: (style: string) => ArrowheadSpec | undefined;
export declare const toScreen: ([x, y]: [number, number], canvasSize: [number, number]) => [number, number];
export declare const hexToRgba: (hex: string) => [number, number, number, number] | undefined;
export declare const rgbToHex: (color: [number, number, number]) => string;
export declare const rgbaToHex: (color: [number, number, number, number]) => string;
export declare const hsvToRGB: (hsv: [number, number, number]) => [number, number, number];
export declare const toSvgPaintProperty: (color: Color<number>) => string;
export declare const toSvgOpacityProperty: (color: Color<number>) => number;
export declare const round2: (n: number) => number;
export declare const roundTo: (n: number, digits: number) => number;
export declare const normList: (xs: number[]) => number;
export declare const eqNum: (x: number, y: number) => boolean;
export declare const eqList: (xs: number[], ys: number[]) => boolean;
export declare const bBoxDims: (properties: Properties<number>, shapeType: ShapeType) => [number, number];
export declare const scalev: (c: number, xs: number[]) => number[];
export declare const addv: (xs: number[], ys: number[]) => number[];
export declare const subv: (xs: number[], ys: number[]) => number[];
export declare const negv: (xs: number[]) => number[];
export declare const dot: (xs: number[], ys: number[]) => number;
export declare const floatV: (contents: ad.Num) => FloatV<ad.Num>;
export declare const boolV: (contents: boolean) => BoolV;
export declare const strV: (contents: string) => StrV;
export declare const pathDataV: (contents: PathCmd<ad.Num>[]) => PathDataV<ad.Num>;
export declare const ptListV: (contents: ad.Num[][]) => PtListV<ad.Num>;
export declare const colorV: (contents: Color<ad.Num>) => ColorV<ad.Num>;
export declare const listV: (contents: ad.Num[]) => ListV<ad.Num>;
export declare const vectorV: (contents: ad.Num[]) => VectorV<ad.Num>;
export declare const matrixV: (contents: ad.Num[][]) => MatrixV<ad.Num>;
export declare const tupV: (contents: ad.Num[]) => TupV<ad.Num>;
export declare const llistV: (contents: ad.Num[][]) => LListV<ad.Num>;
export declare const black: () => ColorV<ad.Num>;
export declare const white: () => ColorV<ad.Num>;
export declare const noPaint: () => ColorV<ad.Num>;
export declare const resolveRhsName: ({ block, subst, locals }: Context, name: BindingForm<A>) => ResolvedName;
export declare const prettyPrintResolvedPath: (p: ResolvedPath<A>) => string;
export declare const prettyPrintPath: (p: Path<A>) => string;
export declare const prettyPrintExpr: (arg: Expr<A>, ppPath: (p: Path<A>) => string) => string;
export declare const prettyPrintFn: (fn: Fn) => string;
export declare const val: (v: Value<ad.Num>) => Val<ad.Num>;
export declare const linePts: ({ start, end }: LineProps) => [ad.Num[], ad.Num[]];
export declare const getStart: ({ start }: LineProps) => ad.Num[];
export declare const getEnd: ({ end }: LineProps) => ad.Num[];
export declare function isLeft<A, B>(val: Either<A, B>): val is Left<A>;
export declare function isRight<A, B>(val: Either<A, B>): val is Right<B>;
export declare function toLeft<A>(val: A): Left<A>;
export declare function toRight<B>(val: B): Right<B>;
export declare function ToLeft<A, B>(val: A): Either<A, B>;
export declare function ToRight<A, B>(val: B): Either<A, B>;
export declare function foldM<A, B, C>(xs: A[], f: (acc: B, curr: A, i: number) => Either<C, B>, init: B): Either<C, B>;
/**
 * Gets the string value of a property.  If the property cannot be converted
 * to a string, throw an exception.
 *
 * @param prop Get the string value of this property
 * @param dft Optional default value (if you don't want an exception)
 * @returns string value of the property
 */
export declare const getAdValueAsString: (prop: Value<ad.Num>, dft?: string) => string;
export {};
//# sourceMappingURL=Util.d.ts.map