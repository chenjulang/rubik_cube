/** directed edge */
export interface Edge<I, E> {
    /** initial vertex */
    i: I;
    /** terminal vertex */
    j: I;
    /** edge label */
    e: E;
}
/** directed multigraph with node keys `I` and labels `L` and edge labels `E` */
export default class Graph<I, L = undefined, E = undefined> {
    private g;
    private get;
    /** set `i`'s label to `l`, adding `i` to the graph if not already present */
    setNode(i: I, l: L): void;
    /** @returns whether `i` is in the graph */
    hasNode(i: I): boolean;
    /** @returns fresh array of all node keys in the graph */
    nodes(): I[];
    /** @returns `i`'s label */
    node(i: I): L;
    /**
     * add an edge from `i` to `j` with label `e`
     * @param labelMissing called if `i` or `j`'s label is missing; default throws
     */
    setEdge({ i, j, e }: Edge<I, E>, labelMissing?: () => L): void;
    /**
     * throws if `i` is absent
     * @returns fresh array of `i`'s in-edges
     */
    inEdges(i: I): Edge<I, E>[];
    /**
     * throws if `i` is absent
     * @returns fresh array of `i`'s out-edges
     */
    outEdges(i: I): Edge<I, E>[];
    /** @returns number of nodes in the graph */
    nodeCount(): number;
    /** @returns fresh array of all nodes that have no in-edges */
    sources(): I[];
    /** @returns fresh array of all nodes that have no out-edges */
    sinks(): I[];
    /**
     * throws if the graph contains a cycle
     * @returns fresh array of all nodes in topological order
     */
    topsort(): I[];
    /**
     * throws if `i` is absent
     * @returns fresh set of all nodes reachable from `i`, including `i`
     */
    descendants(i: I): Set<I>;
    /**
     * not guaranteed to be exhaustive
     * @returns empty array if acyclic, else nonempty array of cycles
     */
    findCycles(): I[][];
}
//# sourceMappingURL=Graph.d.ts.map