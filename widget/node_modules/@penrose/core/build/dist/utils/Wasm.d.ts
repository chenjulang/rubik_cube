/** Section ids. */
export declare const SECTION: {
    TYPE: number;
    IMPORT: number;
    FUNCTION: number;
    EXPORT: number;
    CODE: number;
};
/** `importdesc` leading bytes. */
export declare const IMPORT: {
    FUNCTION: number;
    MEMORY: number;
};
/** `exportdesc` leading bytes. */
export declare const EXPORT: {
    FUNCTION: number;
};
/** Type bytes. */
export declare const TYPE: {
    FUNCTION: number;
    f64: number;
    i32: number;
};
/** `limits` leading bytes. */
export declare const LIMITS: {
    NO_MAXIMUM: number;
};
/** Instruction opcodes. */
export declare const OP: {
    if: number;
    call: number;
    drop: number;
    select: number;
    f64: {
        load: number;
        store: number;
        const: number;
        eq: number;
        lt: number;
        gt: number;
        le: number;
        ge: number;
        abs: number;
        neg: number;
        ceil: number;
        floor: number;
        trunc: number;
        nearest: number;
        sqrt: number;
        add: number;
        sub: number;
        mul: number;
        div: number;
        min: number;
        max: number;
    };
    i32: {
        load: number;
        const: number;
        eqz: number;
        add: number;
        and: number;
        or: number;
    };
    local: {
        get: number;
        set: number;
        tee: number;
    };
};
/** `end` opcode. */
export declare const END = 11;
/**
 * A mutable object to which individual bytes can be written. Exported only for
 * testing purposes; prefer `Target`.
 */
export interface Byter {
    /**
     * Write a single byte.
     * @param b the byte
     */
    byte(b: number): void;
}
/**
 * Writes a 32-bit signed integer to a target. Exported only for testing
 * purposes; prefer `Count`, `intSize`, or `Module` depending on your use case.
 * @param t target
 * @param n integer to write
 */
export declare const int: (t: Byter, n: number) => void;
/**
 * A mutable object to which bytes, 32-bit signed integers, 64-bit
 * floating-point numbers, and ASCII strings can be written.
 */
export interface Target extends Byter {
    /**
     * Write a LEB128-encoded 32-bit signed integer.
     * @param n the integer
     */
    int(n: number): void;
    /**
     * Write an IEEE 754-2019 little-endian 64-bit floating-point number.
     * @param x the number
     */
    f64(x: number): void;
    /**
     * Write an ASCII string as a vector of bytes.
     * @param s the string
     */
    ascii(s: string): void;
}
/**
 * A `Target` that doesn't actually put bytes anywhere, and instead just counts
 * how many bytes would be written. Useful for calculating the size of a
 * `Module` before allocating one big buffer to store its bytes, because
 * JavaScript typed arrays cannot be resized after construction.
 */
export declare class Count implements Target {
    size: number;
    byte(): void;
    int(n: number): void;
    f64(): void;
    ascii(s: string): void;
}
/**
 * @param n integer to encode
 * @returns number of bytes to encode as signed LEB128
 */
export declare const intSize: (n: number) => number;
/**
 * A `Target` which preallocates a byte buffer of known size (perhaps computed
 * via `Count`) with the standard 8-byte preamble, and writes data to it,
 * incrementing an internal byte index as it goes.
 */
export declare class Module implements Target {
    bytes: Uint8Array;
    count: Count;
    floatIn: Float64Array;
    floatOut: Uint8Array;
    /**
     * Allocates a byte buffer for a Wasm module, automatically adding the
     * standard 8 bytes for the preamble.
     * @param sumSectionSizes number of bytes in the module, minus 8 for preamble
     */
    constructor(sumSectionSizes: number);
    byte(b: number): void;
    int(n: number): void;
    f64(x: number): void;
    ascii(s: string): void;
}
//# sourceMappingURL=Wasm.d.ts.map