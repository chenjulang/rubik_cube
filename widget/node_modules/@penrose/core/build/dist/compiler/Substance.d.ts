import { A, C, Identifier } from "../types/ast";
import { Env } from "../types/domain";
import { ParseError, PenroseError, SubstanceError } from "../types/errors";
import { ApplyPredicate, SubExpr, SubProg, SubRes, SubstanceEnv, SubStmt, TypeConsApp } from "../types/substance";
import { Result } from "../utils/Error";
export declare const parseSubstance: (prog: string) => Result<SubProg<C>, ParseError>;
/**
 * Top-level function for the Substance parser and checker. Given a Substance program string and Domain environment, it outputs either a `PenroseError` or `Env` and `SubstanceEnv` contexts.
 *
 * @param prog Substance program string
 * @param env  Domain environment
 */
export declare const compileSubstance: (prog: string, env: Env) => Result<SubRes, PenroseError>;
export declare const postprocessSubstance: (prog: SubProg<A>, env: Env) => SubstanceEnv;
interface WithEnv<T> {
    env: Env;
    contents: T;
}
interface WithEnvAndType<T> {
    env: Env;
    contents: T;
    type: TypeConsApp<A>;
}
type CheckerResult<T> = Result<WithEnv<T>, SubstanceError>;
type ResultWithType<T> = Result<WithEnvAndType<T>, SubstanceError>;
/**
 * Top-level function for the Substance semantic checker. Given a Substance AST and an initial context, it outputs either a `SubstanceError` or an `Env` context.
 *
 * @param prog compiled AST of a Domain program
 * @param env  environment from the Domain checker
 */
export declare const checkSubstance: (prog: SubProg<A>, env: Env) => CheckerResult<SubProg<A>>;
export declare const checkPredicate: (stmt: ApplyPredicate<A>, env: Env) => CheckerResult<ApplyPredicate<A>>;
export declare const subtypeOf: <T1 extends {
    tag: string;
    nodeType: import("../types/ast").NodeType;
}, T2 extends {
    tag: string;
    nodeType: import("../types/ast").NodeType;
}>(type1: ResultWithType<T1>, type2: ResultWithType<T2>) => CheckerResult<[T1, T2]>;
export declare const checkExpr: (expr: SubExpr<A>, env: Env, variable?: Identifier<A>) => ResultWithType<SubExpr<A>>;
export declare const checkVar: (variable: Identifier<A>, env: Env) => ResultWithType<Identifier<A>>;
export declare const prettySubstance: (prog: SubProg<A>) => string;
export declare const prettyStmt: (stmt: SubStmt<A>) => string;
export declare const prettySubNode: (node: SubExpr<A> | SubStmt<A> | TypeConsApp<A>) => string;
export declare const prettyPredicate: (pred: ApplyPredicate<A>) => string;
export {};
//# sourceMappingURL=Substance.d.ts.map